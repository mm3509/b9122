# Assignment 5

The maximum comment share for this assignment, as well as the final, is 20%; for debugging, it's 90%.

__Notes on generative AI__: Some students used generative AI in assignments, and admitted to using it, therefore this assignment is not all generative AI. But most of you did answer my request, so to give you an idea of the problems that AI can solve in your future jobs, it has 2-4 questions for you to produce code generated by AI (10-11, 13-14), and 1-2 questions at a higher-level, to compare the answers given by generative AI. The first questions, before 1-7, prepare you for the final exam.

In the generative AI questions, you may need to edit the answer from generative AI in order to pass comments, style, etc. Even though it is generated by AI, you must still "own" your answer and understand it, not copy blindly.

Please note that it's only in these 2-4 questions, marked as such, that you can use generative AI. You cannot use generative AI in the text questions asking you to discuss generative AI. In all other questions, as well as in the final exam, generative AI is strictly forbidden.

## 1: debugging (MSAFA only, 20 points)

Use case: you have a web server recording users' answers to a survey. Each question is on a different webpage and you save answers periodically (so that you have some data, even when the user doesn't finish the survey). You want to record the time taken between pages, so you can estimate the average time that each question takes.

This function takes three arguments:

- a survey, which is a dictionary, where the keys are the questions and the values are the answers

- a question, which is a string

- an answer, which is also a string

It returns a dictionary, which contains the survey's answers. It also contains a special key-value pair, where the key is the value of the "global variable" `PROGRESS_KEY` (global variables are variables declared at the top of the script, usually in upper case; and should not change during the script), and the value is a list of strings that indicate the completion of each page in the survey.

The function has a bug and does not pass the doc-tests. Understand the bug, fix it by changing as few lines as possible, and add a comment explaining the bug.

## 2: debugging (MSFE only, 10 points)

Use case: generating data to test the function in assignment 3, exercise 6 (grid increasing in both directions).

This function generates a grid of values that should be increasing by row and by column. It has 2 bugs and raises an assertion error. Understand the bugs, fix them by changing as few lines as possible, and add two comments, one for each bug.

## 3: repeat a line multiple times (MSAFA only, 20 points)

Use case: you have a spreadsheet where one column has one value for the first row, and no value in the other rows. You want to copy-paste a string such that those values get filled. In this simple case, it's easier to copy-paste inside the spread-sheet, or use drag-down copy-pasting; but for more complex cases (multiple sheets, or one sheet with multiple headings), doing this in code could be faster (and you can use Python to read and write Excel files, with the library `openpyxl`).

This function takes a string `txt`, with text, and an integer `n`. It returns each line in the string `txt` repeated `n` times.

**Note**: in Python, we represent a newline with `\n`. The backslash is called an "escape character"; together with another character, it represents characters such as newlines (`\n`) or tabs (`\t`). But inside doc-tests, the escape character itself needs to be escaped, so inside a doc-test, a newline is `\\n` (that's because doc-strings are strings that first convert to code, so the double escape character converts to a single escape character, which then applies to the character `n` to produce a newline).

## 4: merge sorted lists (MSAFA only, 20 points)

This problem is an easy level question from [LeetCode](https://leetcode.com/problems/merge-two-sorted-lists/description/).

The function takes two lists of integers that are already sorted, and returns a new list with the same integers, also sorted. You may not use sorting functions like `sorted()` or `.sort()` at any point in the function.

## 5: gross value triplets (MSAFA only, 20 points)

Use case: this is an interview question.

This function takes as input a list of integers of length `n`. For a triplet `i, j, k`, such that `0 <= i <= j <= k <= n`, the gross value is (using Python's slice notation):

```
gross_value = sum(alist[:i]) - sum(alist[i:j]) + sum(alist[j:k]) - sum(alist[k:])
```

For example, if the array is `[-5, 3, 9, 4]` as in the doc-tests, the optimal triplet is `(0, 1, 4)`: `sum(alist[:0]) - sum(alist[0:1]) + sum(alist[1:4]) - sum(alist[4:]) = 0 - (-5) + (3 + 9 + 4) - 0 = 21`.

If the sliced array is empty, then its sum is zero, for example, `sum(alist[:0])` or `sum(alist[n:])`.

The function returns an integer, which is the maximum gross value among all triplets. For specific values, please see the doc-tests.

Write a slow version of your function with a trivial implementation with complexity O(n^4), i.e. 3 nested for loops with a sum inside.

## 6: gross value triplets + speed (MSFE only, 20 points)

This exercise is the same as the previous one, except that you also need to write a fast version of the function.

## 7: PIN number to words (MSFE only, 20 points)

Most people use birthdays or birth years as PINs (personal identification numbers), which are insecure but easy to remember. The most secure PINs are random, but hard to remember. This exercise converts a random PIN into a word, which is easier to remember than a number, thus getting both advantages (secure and easy-to-remember).

Here is one intuitive correspondence of digits to letters:

- 1 is T or D because they have 1 downstroke

- 2 is N because it has 2 downstrokes

- 3 is M because it has 3 downstrokes

- and so on, as detailed in the file `exercise_pin.py`.

The remaining letters without correspondence, such as vowels, are ignored. Thus, the word `dynamo` encodes the number `123`: D is 1, N is 2, M is 3, and the letters without a correspondence (Y, A, and O) are ignored.

In this exercise, you'll implement this conversion in three steps:

- convert an English word to a number, according to the correspondence above;

- from a list of all English words and the above function, and build a dictionary where a number is associated with a list of words that match that number;

- taking a number as input and with the above dictionary, return the list of all English words that match that number, in alphabetical order.

The file `exercise_pin.py` has a class `Converter` and methods that implement these steps. Add defensive programming doc-tests and complete the methods marked with `# TODO` to pass the doc-tests.

Note:

- use the variable `ENGLISH_WORDS_FILEPATH`, defined at the top of the file, to load the file with English words (instead of `english.txt`, because Autograder runs your code from a different directory).

## 10: web scraping with BeautifulSoup, genAI allowed (15 points for MSFE, 20 points for MSAFA)

Web scraping consists of collecting data from the internet, similar to how `yfinance` collected data from Yahoo Finance, but applying to any page on the internet. Web scraping is an example of a task that is boring and long for humans and easy for AI. In this exercise and the next, you'll use generative AI to find one piece of information, the current federal funds rate from a webpage.

In this exercise, you'll use BeautifulSoup, a Python library that makes it easier to "parse" webpages. "Parsing" means extracting or organizing information from text (all webpages are text). 

Ask generative AI to write a function that scrapes the latest value of the federal funds rate from [this page](https://www.federalreserve.gov/releases/h15/). You should ask the AI to specifically use BeautifulSoup in the answer. You can check that a script uses BeautifulSoup if it calls `import bs4` (which stands for Beautiful Soup, version 4) at the top, and calls functions or objects from that `bs4` library.

Change the name of the function to `get_federal_funds_rate()` and make it take an argument, the URL above, so that Autograder can find it and run it. Add the prompt that you used for this answer in a comment at the top of the file.

If you cannot get AI to generate this, please ask us for help in office hours.

## 11: web scraping without BeautifulSoup, genAI allowed (15 points for MSFE, 20 points for MSAFA)

This exercise is the same as before, except that now you should ask generative AI to NOT use BeautifulSoup.

If the answer has a line with a long regular expression, you can add this at the end of the line to avoid losing points due to style errors: `  # noqa: E501`.

I asked several generative AI providers for this, multiple times, and none of them could find the federal funds rate. Either way, whether you are able to run the code or not:

- add the prompt you used at the top of the file in a comment;

- add the answer from generative AI;

- change the name of the function to `get_federal_funds_rate()` and make it take an argument (the URL above), so that Autograder can find it and run it.

## 12: comparison of generative AI answers, genAI NOT allowed (15 points for MSFE, 20 points for MSAFA)

Make sure to read and understand the generative AI answer to both previous exercises (for example, if the code from generative AI in the previous answer uses `import re`, you should learn about regular expressions). Ignore the problem that generative AI cannot yet solve web scraping without BeautifulSoup, and imagine that it was able to. Write a paragraph (without generative AI) with your opinion on why one approach (with or without BeautifulSoup) is or could be better than the other.

## 13: backtracking, genAI allowed (MSFE only, 15 points)

This exercise solves a Sudoku that is partially filled. The function should take one argument, a list of lists (similar to robot counting paths). Each element in the inner list represents a cell with a number from 1 to 9, or 0 if the cell is empty. It returns a list of lists with the solution (if it exists) and `False` otherwise.

To solve this, we could iterate through every possible number in every empty cell, and check if it is valid. This would be called "brute force" and would take a long time: if a grid is half-full, it has around 40 empty cells, and the possible number of combinations is `9 ** 40 = 1.47e38`.

Instead, a better approach is "backtracking": we try a number (any number) in an empty cell. If it is invalid, or if the grid has no solution then we erase that number (we go back on our tracks, or "backtrack") and try another number. If there is not invalid consequence of writing that number, then the grid may have a solution, and we hold that number until we either find it is invalid (because some other number later on cannot be placed) or because we found a solution.

Ask generative AI to generate a function that takes as input and solves the sudoku with backtracking.

Change the name of the function `solve_sudoku()`, so that Autograder can run it. Add the prompt that you used for this as a comment at the top of the file.

If the answer uses object-oriented programming (OOP), change the prompt so it does not use OOP.

__Note__: The solution may use a "closure", a function defined within a function. In this case, the inner function has access to the variables defined in the outer function. If generative AI uses this and you do not understand this, and do not want to learn it, you should ask it to generate an answer without closures.

## 14: backtracking, genAI allowed (MSFE only, 15 points)

This execise is the same as the previous, except that in this one the answer should use object-oriented programming (OOP). The name of the class should be `SudokuSolver`, it should be initialized with a list of lists as in the previous question, and should have a public method `.solve()` that Autograder can run.

## 15: comparison of generative AI answers, genAI NOT allowed (MSFE only, 15 points)

Consider the previous two solutions to Sudoku with backtracking. Write 1-4 paragraphs (without using generative AI) answering:

- Which answer do you like best?

- Which features of either solution do you understand well?

- Which features of the solution do you understand more or less?

- Which features do you not understand at all?
